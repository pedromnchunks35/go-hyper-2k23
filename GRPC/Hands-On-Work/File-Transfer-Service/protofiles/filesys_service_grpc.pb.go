// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.23.4
// source: filesys_service.proto

package protofiles

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// FileSharingClient is the client API for FileSharing service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FileSharingClient interface {
	// ? Procedure for getting the file by giving details
	GetFile(ctx context.Context, in *FileDetails, opts ...grpc.CallOption) (FileSharing_GetFileClient, error)
	// ? Procedure for saving the file, which will return file details
	SaveFile(ctx context.Context, opts ...grpc.CallOption) (FileSharing_SaveFileClient, error)
}

type fileSharingClient struct {
	cc grpc.ClientConnInterface
}

func NewFileSharingClient(cc grpc.ClientConnInterface) FileSharingClient {
	return &fileSharingClient{cc}
}

func (c *fileSharingClient) GetFile(ctx context.Context, in *FileDetails, opts ...grpc.CallOption) (FileSharing_GetFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &FileSharing_ServiceDesc.Streams[0], "/protofiles.FileSharing/GetFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileSharingGetFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileSharing_GetFileClient interface {
	Recv() (*FileContent, error)
	grpc.ClientStream
}

type fileSharingGetFileClient struct {
	grpc.ClientStream
}

func (x *fileSharingGetFileClient) Recv() (*FileContent, error) {
	m := new(FileContent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *fileSharingClient) SaveFile(ctx context.Context, opts ...grpc.CallOption) (FileSharing_SaveFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &FileSharing_ServiceDesc.Streams[1], "/protofiles.FileSharing/SaveFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileSharingSaveFileClient{stream}
	return x, nil
}

type FileSharing_SaveFileClient interface {
	Send(*FileContent) error
	CloseAndRecv() (*Confirmation, error)
	grpc.ClientStream
}

type fileSharingSaveFileClient struct {
	grpc.ClientStream
}

func (x *fileSharingSaveFileClient) Send(m *FileContent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *fileSharingSaveFileClient) CloseAndRecv() (*Confirmation, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Confirmation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FileSharingServer is the server API for FileSharing service.
// All implementations must embed UnimplementedFileSharingServer
// for forward compatibility
type FileSharingServer interface {
	// ? Procedure for getting the file by giving details
	GetFile(*FileDetails, FileSharing_GetFileServer) error
	// ? Procedure for saving the file, which will return file details
	SaveFile(FileSharing_SaveFileServer) error
	mustEmbedUnimplementedFileSharingServer()
}

// UnimplementedFileSharingServer must be embedded to have forward compatible implementations.
type UnimplementedFileSharingServer struct {
}

func (UnimplementedFileSharingServer) GetFile(*FileDetails, FileSharing_GetFileServer) error {
	return status.Errorf(codes.Unimplemented, "method GetFile not implemented")
}
func (UnimplementedFileSharingServer) SaveFile(FileSharing_SaveFileServer) error {
	return status.Errorf(codes.Unimplemented, "method SaveFile not implemented")
}
func (UnimplementedFileSharingServer) mustEmbedUnimplementedFileSharingServer() {}

// UnsafeFileSharingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FileSharingServer will
// result in compilation errors.
type UnsafeFileSharingServer interface {
	mustEmbedUnimplementedFileSharingServer()
}

func RegisterFileSharingServer(s grpc.ServiceRegistrar, srv FileSharingServer) {
	s.RegisterService(&FileSharing_ServiceDesc, srv)
}

func _FileSharing_GetFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileDetails)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileSharingServer).GetFile(m, &fileSharingGetFileServer{stream})
}

type FileSharing_GetFileServer interface {
	Send(*FileContent) error
	grpc.ServerStream
}

type fileSharingGetFileServer struct {
	grpc.ServerStream
}

func (x *fileSharingGetFileServer) Send(m *FileContent) error {
	return x.ServerStream.SendMsg(m)
}

func _FileSharing_SaveFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FileSharingServer).SaveFile(&fileSharingSaveFileServer{stream})
}

type FileSharing_SaveFileServer interface {
	SendAndClose(*Confirmation) error
	Recv() (*FileContent, error)
	grpc.ServerStream
}

type fileSharingSaveFileServer struct {
	grpc.ServerStream
}

func (x *fileSharingSaveFileServer) SendAndClose(m *Confirmation) error {
	return x.ServerStream.SendMsg(m)
}

func (x *fileSharingSaveFileServer) Recv() (*FileContent, error) {
	m := new(FileContent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FileSharing_ServiceDesc is the grpc.ServiceDesc for FileSharing service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FileSharing_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "protofiles.FileSharing",
	HandlerType: (*FileSharingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetFile",
			Handler:       _FileSharing_GetFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SaveFile",
			Handler:       _FileSharing_SaveFile_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "filesys_service.proto",
}
