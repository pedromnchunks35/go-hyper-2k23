# Sorting Algorithms
###  1. Bubble Sort [Link](BubbleSort/bubblesort.go)
- It is meant to swap 2 elements that are in the wrong order
- Time complexity is O(n^2)
###   2. Selection Sort [Link](SelectionSort/selectionSort.go)
- It is used to stort the elements by repeatedly finding the minimum element and placing it at the first in the unsorted part of the array
- It is the contrast of the bubble, it puts the minimum member at the begginining instead of putting the biggest to the right
- Time complexity is O(n^2)
###   3. Insertion Sort [Link](InsertionSort/insertionSort.go)
- Also timecomplexity of O(n^2)
###   4. Merge Sort [Link](MergeSort/mergeSort.go)
- It uses recursion to divide the array, making it smaller and smaller comparing after only the first members of the array
- Bad side is that it uses to much pointers to memory
- It is O(n*logn)
###   5. Quick Sort [Link](QuickSort/quickSort.go)
- Is one of the most efficient, it divides the array in multiple parts and by changing the temp array of positions is also changing the main array
- It is O(n*logn)
# Search Algorithms
###   1. Linear Search [Link](LinearSearch/linearSearch.go)
###   2. Binary Search [Link](BinarySearch/binarySearch.go)
# Graph Algorithms
###  1. Depth-First Search (DFS)
###  2. Breadth-First Search (BFS)
###  3. Dijkstr's Algorithm
###  4. Minimum Spanning Tree (MST)
# Dynamic Programming
###  1. Memoization 
###  2. Recursion
# Tree Algorithms
###  1. Binary Trees
###  2. Binary Search Trees
###  3. AVL Trees
###  4. Red-Black Trees
###  5. Pre-orderer
###  6. In-order
###  6. Post-order
# Hashing
###  1. Hash Functions
###  2. Collision Resolution(Separate Chaining and Open Addressing)
###  3. SHA-1
###  4. SHA-256
###  5. MD5
# Greedy Algorithms
###  1. Activity Selection Problem
###  2. Knapsack problem
# String Algorithms
###  1. Naive
###  2. Rabin-karp
###  3. Knuth-Morris-Pratt
###  4. Radix Sort
###  5. Run-Length Encoding